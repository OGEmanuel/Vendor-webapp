/* tslint:disable */
/* eslint-disable */
/**
 * Vendor Docs
 * Vendor endpoints...
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountPublicDto
 */
export interface AccountPublicDto {
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'emailActivated': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'profilePhoto': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'phoneActivated': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof Address
     */
    'country': string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof Address
     */
    'countryCode': string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof Address
     */
    'state': string;
    /**
     * State or region code (e.g., LA)
     * @type {string}
     * @memberof Address
     */
    'stateCode': string;
    /**
     * City name (e.g., Lagos)
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof Address
     */
    'address': string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof Address
     */
    'latitude': number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof Address
     */
    'longitude': number;
    /**
     * Additional notes or instructions for the address
     * @type {string}
     * @memberof Address
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateOutletDTO
 */
export interface CreateOutletDTO {
    /**
     * Unique identifier for the vendor associated with this outlet.
     * @type {string}
     * @memberof CreateOutletDTO
     */
    'vendorId': string;
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof CreateOutletDTO
     */
    'outletName': string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof CreateOutletDTO
     */
    'caption': string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof CreateOutletDTO
     */
    'marketSegments': Array<string>;
    /**
     * Address details of the outlet.
     * @type {Address}
     * @memberof CreateOutletDTO
     */
    'address'?: Address;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof CreateOutletDTO
     */
    'config'?: OutletConfig;
}
/**
 * 
 * @export
 * @interface CreateVendorProfileDTO
 */
export interface CreateVendorProfileDTO {
    /**
     * Unique identifier for the vendor account.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'accountId': string;
    /**
     * URL to the vendor’s logo image.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'logo'?: string;
    /**
     * URL to the vendor’s cover photo image.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'coverPhoto'?: string;
    /**
     * Name of the vendor, used across the TukShop platform.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'vendorName'?: string;
    /**
     * Short description of the vendor’s business.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'shortDescription'?: string;
    /**
     * Detailed description of the vendor’s business.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'longDescription'?: string;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof CreateVendorProfileDTO
     */
    'contactPhone'?: string;
}
/**
 * 
 * @export
 * @interface DaysOfWork
 */
export interface DaysOfWork {
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'monday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'tuesday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'wednesday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'thursday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'friday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'saturday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'sunday': OpeningHours;
}
/**
 * 
 * @export
 * @interface DeleteAccountDTO
 */
export interface DeleteAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof DeleteAccountDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface InviteMemberDTO
 */
export interface InviteMemberDTO {
    /**
     * Unique identifier for the vendor to which this member belongs.
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'vendorId': string;
    /**
     * Unique identifier for the outlet associated with this member.
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'outletId'?: string;
    /**
     * Unique identifier for the user account of the member.
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'accountId': string;
    /**
     * Full name of the member.
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'name'?: string;
    /**
     * Role of the member within the outlet.
     * @type {number}
     * @memberof InviteMemberDTO
     */
    'role': number;
    /**
     * Status of the member within the outlet.
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'status'?: InviteMemberDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberDTO
     */
    'phone': string;
}

export const InviteMemberDTOStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type InviteMemberDTOStatusEnum = typeof InviteMemberDTOStatusEnum[keyof typeof InviteMemberDTOStatusEnum];

/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * Unique identifier for the member, automatically generated by MongoDB.
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * Unique identifier for the vendor to which this member belongs.
     * @type {string}
     * @memberof Member
     */
    'vendorId': string;
    /**
     * Unique identifier for the outlet associated with this member.
     * @type {string}
     * @memberof Member
     */
    'outletId'?: string;
    /**
     * Unique identifier for the user account of the member.
     * @type {string}
     * @memberof Member
     */
    'accountId': string;
    /**
     * Full name of the member.
     * @type {string}
     * @memberof Member
     */
    'name'?: string;
    /**
     * Role of the member within the outlet.
     * @type {string}
     * @memberof Member
     */
    'role': MemberRoleEnum;
    /**
     * Status of the member within the outlet.
     * @type {string}
     * @memberof Member
     */
    'status'?: MemberStatusEnum;
    /**
     * Timestamp when the member document was created.
     * @type {string}
     * @memberof Member
     */
    'createdAt': string;
    /**
     * Timestamp when the member document was last updated.
     * @type {string}
     * @memberof Member
     */
    'updatedAt': string;
}

export const MemberRoleEnum = {
    SuperAdmin: 'super-admin',
    Admin: 'admin',
    Manager: 'manager'
} as const;

export type MemberRoleEnum = typeof MemberRoleEnum[keyof typeof MemberRoleEnum];
export const MemberStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type MemberStatusEnum = typeof MemberStatusEnum[keyof typeof MemberStatusEnum];

/**
 * 
 * @export
 * @interface MemberCredential
 */
export interface MemberCredential {
    /**
     * 
     * @type {string}
     * @memberof MemberCredential
     */
    'vendorName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberCredential
     */
    'vendorId': string;
    /**
     * 
     * @type {string}
     * @memberof MemberCredential
     */
    'vendorStatus': string;
    /**
     * 
     * @type {object}
     * @memberof MemberCredential
     */
    'role': object;
    /**
     * 
     * @type {string}
     * @memberof MemberCredential
     */
    'memberId': string;
    /**
     * 
     * @type {string}
     * @memberof MemberCredential
     */
    'defaultOutletId': string;
}
/**
 * 
 * @export
 * @interface OpeningHours
 */
export interface OpeningHours {
    /**
     * Opening time (e.g., 09:00)
     * @type {string}
     * @memberof OpeningHours
     */
    'open': string;
    /**
     * Closing time (e.g., 17:00)
     * @type {string}
     * @memberof OpeningHours
     */
    'close': string;
    /**
     * Indicates if the outlet is always open
     * @type {boolean}
     * @memberof OpeningHours
     */
    'alwaysOpen': boolean;
}
/**
 * 
 * @export
 * @interface Outlet
 */
export interface Outlet {
    /**
     * Unique identifier for the outlet, automatically generated by MongoDB.
     * @type {string}
     * @memberof Outlet
     */
    'id': string;
    /**
     * Unique identifier for the vendor associated with this outlet.
     * @type {string}
     * @memberof Outlet
     */
    'vendorId': string;
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'outletName': string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'caption': string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof Outlet
     */
    'marketSegments': Array<string>;
    /**
     * Unique identifier for the zone where the outlet is located.
     * @type {string}
     * @memberof Outlet
     */
    'zoneId': string;
    /**
     * Address details of the outlet.
     * @type {Address}
     * @memberof Outlet
     */
    'address'?: Address;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof Outlet
     */
    'config'?: OutletConfig;
    /**
     * Timestamp when the outlet document was created.
     * @type {string}
     * @memberof Outlet
     */
    'createdAt': string;
    /**
     * Verification status of the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'verificationStatus': OutletVerificationStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'requiresVerification': boolean;
    /**
     * Timestamp when the outlet document was last updated.
     * @type {string}
     * @memberof Outlet
     */
    'updatedAt': string;
}

export const OutletVerificationStatusEnum = {
    Pending: 'pending',
    Approved: 'approved'
} as const;

export type OutletVerificationStatusEnum = typeof OutletVerificationStatusEnum[keyof typeof OutletVerificationStatusEnum];

/**
 * 
 * @export
 * @interface OutletConfig
 */
export interface OutletConfig {
    /**
     * Minimum delivery window in minutes
     * @type {number}
     * @memberof OutletConfig
     */
    'minimumDeliveryWindow': number;
    /**
     * Automatically accept orders
     * @type {boolean}
     * @memberof OutletConfig
     */
    'autoAcceptOrders'?: boolean;
    /**
     * Allow customers to pick up orders at the outlet
     * @type {boolean}
     * @memberof OutletConfig
     */
    'allowPickupAtOutlet'?: boolean;
    /**
     * Enable or disable notifications for new orders
     * @type {boolean}
     * @memberof OutletConfig
     */
    'enableOrderNotifications'?: boolean;
    /**
     * Default preparation time for orders in minutes
     * @type {string}
     * @memberof OutletConfig
     */
    'defaultPreparationTime'?: string;
    /**
     * Minimum order amount for delivery
     * @type {number}
     * @memberof OutletConfig
     */
    'minimumOrderAmount'?: number;
    /**
     * Maximum number of orders to accept simultaneously
     * @type {number}
     * @memberof OutletConfig
     */
    'maxConcurrentOrders'?: number;
    /**
     * Operating hours of the outlet
     * @type {string}
     * @memberof OutletConfig
     */
    'operatingHours'?: string;
    /**
     * Allow or disallow cash on delivery
     * @type {boolean}
     * @memberof OutletConfig
     */
    'allowCashOnDelivery'?: boolean;
    /**
     * Contact email for vendor support
     * @type {string}
     * @memberof OutletConfig
     */
    'supportContactEmail'?: string;
    /**
     * Contact phone number for vendor support
     * @type {string}
     * @memberof OutletConfig
     */
    'supportContactPhone'?: string;
    /**
     * 
     * @type {DaysOfWork}
     * @memberof OutletConfig
     */
    'daysOfWork': DaysOfWork;
    /**
     * Start date of temporary closure (ISO 8601 format)
     * @type {string}
     * @memberof OutletConfig
     */
    'temporaryClosureStart'?: string;
    /**
     * End date of temporary closure (ISO 8601 format)
     * @type {string}
     * @memberof OutletConfig
     */
    'temporaryClosureEnd'?: string;
    /**
     * Reason for temporary closure
     * @type {string}
     * @memberof OutletConfig
     */
    'closureReason'?: string;
    /**
     * Indicates if the outlet is currently closed
     * @type {boolean}
     * @memberof OutletConfig
     */
    'isClosed'?: boolean;
}
/**
 * 
 * @export
 * @interface OutletSummary
 */
export interface OutletSummary {
    /**
     * Unique identifier for the outlet, automatically generated by MongoDB.
     * @type {string}
     * @memberof OutletSummary
     */
    'id': string;
    /**
     * Unique identifier for the vendor associated with this outlet.
     * @type {string}
     * @memberof OutletSummary
     */
    'vendorId': string;
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof OutletSummary
     */
    'outletName': string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof OutletSummary
     */
    'caption': string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof OutletSummary
     */
    'marketSegments': Array<string>;
    /**
     * Unique identifier for the zone where the outlet is located.
     * @type {string}
     * @memberof OutletSummary
     */
    'zoneId': string;
    /**
     * Address details of the outlet.
     * @type {Address}
     * @memberof OutletSummary
     */
    'address'?: Address;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof OutletSummary
     */
    'config'?: OutletConfig;
    /**
     * Timestamp when the outlet document was created.
     * @type {string}
     * @memberof OutletSummary
     */
    'createdAt': string;
    /**
     * Verification status of the outlet.
     * @type {string}
     * @memberof OutletSummary
     */
    'verificationStatus': OutletSummaryVerificationStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OutletSummary
     */
    'requiresVerification': boolean;
    /**
     * Timestamp when the outlet document was last updated.
     * @type {string}
     * @memberof OutletSummary
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Review>}
     * @memberof OutletSummary
     */
    'reviews': Array<Review>;
    /**
     * 
     * @type {Array<Member>}
     * @memberof OutletSummary
     */
    'members': Array<Member>;
}

export const OutletSummaryVerificationStatusEnum = {
    Pending: 'pending',
    Approved: 'approved'
} as const;

export type OutletSummaryVerificationStatusEnum = typeof OutletSummaryVerificationStatusEnum[keyof typeof OutletSummaryVerificationStatusEnum];

/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof Review
     */
    'id': string;
    /**
     * Unique identifier for the review account.
     * @type {object}
     * @memberof Review
     */
    'reviewerId': object;
    /**
     * Unique identifier for resource being reviewed.
     * @type {string}
     * @memberof Review
     */
    'resourceId': string;
    /**
     * Review resource type
     * @type {string}
     * @memberof Review
     */
    'resourceType': string;
    /**
     * Review actual review
     * @type {string}
     * @memberof Review
     */
    'body'?: string;
    /**
     * Rating
     * @type {number}
     * @memberof Review
     */
    'rating'?: number;
    /**
     * Timestamp when the vendor document was created.
     * @type {string}
     * @memberof Review
     */
    'createdAt': string;
    /**
     * Timestamp when the vendor document was last updated.
     * @type {string}
     * @memberof Review
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountDTO
 */
export interface UpdateAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'profilePhoto'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'bio'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAccountPasswordDTO
 */
export interface UpdateAccountPasswordDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface UpdateMemberDTO
 */
export interface UpdateMemberDTO {
    /**
     * Unique identifier for the outlet associated with this member.
     * @type {string}
     * @memberof UpdateMemberDTO
     */
    'outletId'?: string;
    /**
     * Full name of the member.
     * @type {string}
     * @memberof UpdateMemberDTO
     */
    'name'?: string;
    /**
     * Role of the member within the outlet.
     * @type {string}
     * @memberof UpdateMemberDTO
     */
    'role': UpdateMemberDTORoleEnum;
    /**
     * Status of the member within the outlet.
     * @type {string}
     * @memberof UpdateMemberDTO
     */
    'status'?: UpdateMemberDTOStatusEnum;
}

export const UpdateMemberDTORoleEnum = {
    SuperAdmin: 'super-admin',
    Admin: 'admin',
    Manager: 'manager'
} as const;

export type UpdateMemberDTORoleEnum = typeof UpdateMemberDTORoleEnum[keyof typeof UpdateMemberDTORoleEnum];
export const UpdateMemberDTOStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type UpdateMemberDTOStatusEnum = typeof UpdateMemberDTOStatusEnum[keyof typeof UpdateMemberDTOStatusEnum];

/**
 * 
 * @export
 * @interface UpdateOutletDTO
 */
export interface UpdateOutletDTO {
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof UpdateOutletDTO
     */
    'outletName': string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof UpdateOutletDTO
     */
    'caption': string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof UpdateOutletDTO
     */
    'marketSegments': Array<string>;
    /**
     * Address details of the outlet.
     * @type {Address}
     * @memberof UpdateOutletDTO
     */
    'address'?: Address;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof UpdateOutletDTO
     */
    'config'?: OutletConfig;
}
/**
 * 
 * @export
 * @interface UpdateVendorDTO
 */
export interface UpdateVendorDTO {
    /**
     * URL to the vendor’s logo image.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'logo'?: string;
    /**
     * URL to the vendor’s cover photo image.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'coverPhoto'?: string;
    /**
     * Name of the vendor, used across the TukShop platform.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'vendorName'?: string;
    /**
     * Short description of the vendor’s business.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'shortDescription'?: string;
    /**
     * Detailed description of the vendor’s business.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'longDescription'?: string;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof UpdateVendorDTO
     */
    'contactPhone'?: string;
    /**
     * Configuration settings for the vendor.
     * @type {VendorConfig}
     * @memberof UpdateVendorDTO
     */
    'config'?: VendorConfig;
}
/**
 * 
 * @export
 * @interface UpdateVendorKYCDTO
 */
export interface UpdateVendorKYCDTO {
    /**
     * KYC (Know Your Customer) credentials for the vendor.
     * @type {VendorKYCCredentials}
     * @memberof UpdateVendorKYCDTO
     */
    'kycCredentials'?: VendorKYCCredentials;
}
/**
 * 
 * @export
 * @interface UpdateVendorPayoutProfileDTO
 */
export interface UpdateVendorPayoutProfileDTO {
    /**
     * Vendor payout profile.
     * @type {VendorPayoutProfile}
     * @memberof UpdateVendorPayoutProfileDTO
     */
    'payoutProfile'?: VendorPayoutProfile;
}
/**
 * 
 * @export
 * @interface Vendor
 */
export interface Vendor {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof Vendor
     */
    'id': string;
    /**
     * Unique identifier for the vendor account.
     * @type {string}
     * @memberof Vendor
     */
    'accountId': string;
    /**
     * URL to the vendor’s logo image.
     * @type {string}
     * @memberof Vendor
     */
    'logo'?: string;
    /**
     * URL to the vendor’s cover photo image.
     * @type {string}
     * @memberof Vendor
     */
    'coverPhoto'?: string;
    /**
     * Name of the vendor, used across the TukShop platform.
     * @type {string}
     * @memberof Vendor
     */
    'vendorName'?: string;
    /**
     * Short description of the vendor’s business.
     * @type {string}
     * @memberof Vendor
     */
    'shortDescription'?: string;
    /**
     * Detailed description of the vendor’s business.
     * @type {string}
     * @memberof Vendor
     */
    'longDescription'?: string;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof Vendor
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof Vendor
     */
    'contactPhone'?: string;
    /**
     * KYC (Know Your Customer) credentials for the vendor.
     * @type {VendorKYCCredentials}
     * @memberof Vendor
     */
    'kycCredentials'?: VendorKYCCredentials;
    /**
     * Configuration settings for the vendor.
     * @type {VendorConfig}
     * @memberof Vendor
     */
    'config'?: VendorConfig;
    /**
     * Vendor payout profile.
     * @type {VendorPayoutProfile}
     * @memberof Vendor
     */
    'payoutProfile'?: VendorPayoutProfile;
    /**
     * Current status of the vendor profile.
     * @type {string}
     * @memberof Vendor
     */
    'status': VendorStatusEnum;
    /**
     * Current verification status of the vendor.
     * @type {string}
     * @memberof Vendor
     */
    'verificationStatus': VendorVerificationStatusEnum;
    /**
     * Flag to check if vendor credentials requires verification
     * @type {boolean}
     * @memberof Vendor
     */
    'requiresVerification': boolean;
    /**
     * 
     * @type {string}
     * @memberof Vendor
     */
    'verificationDeclineReason': string;
    /**
     * Timestamp when the vendor document was created.
     * @type {string}
     * @memberof Vendor
     */
    'createdAt': string;
    /**
     * Timestamp when the vendor document was last updated.
     * @type {string}
     * @memberof Vendor
     */
    'updatedAt': string;
}

export const VendorStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Disabled: 'disabled'
} as const;

export type VendorStatusEnum = typeof VendorStatusEnum[keyof typeof VendorStatusEnum];
export const VendorVerificationStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Approved: 'approved',
    Declined: 'declined',
    AwaitingReview: 'awaiting-review'
} as const;

export type VendorVerificationStatusEnum = typeof VendorVerificationStatusEnum[keyof typeof VendorVerificationStatusEnum];

/**
 * 
 * @export
 * @interface VendorConfig
 */
export interface VendorConfig {
    /**
     * Minimum delivery window in minutes
     * @type {boolean}
     * @memberof VendorConfig
     */
    'overrideOutletConfig': boolean;
    /**
     * Minimum delivery window in minutes
     * @type {number}
     * @memberof VendorConfig
     */
    'minimumDeliveryWindow': number;
    /**
     * Automatically accept orders
     * @type {boolean}
     * @memberof VendorConfig
     */
    'autoAcceptOrders'?: boolean;
    /**
     * Allow customers to pick up orders at the outlet
     * @type {boolean}
     * @memberof VendorConfig
     */
    'allowPickupAtOutlet'?: boolean;
    /**
     * Enable or disable notifications for new orders
     * @type {boolean}
     * @memberof VendorConfig
     */
    'enableOrderNotifications'?: boolean;
    /**
     * Default preparation time for orders in minutes
     * @type {string}
     * @memberof VendorConfig
     */
    'defaultPreparationTime'?: string;
    /**
     * Minimum order amount for delivery
     * @type {number}
     * @memberof VendorConfig
     */
    'minimumOrderAmount'?: number;
    /**
     * Maximum number of orders to accept simultaneously
     * @type {number}
     * @memberof VendorConfig
     */
    'maxConcurrentOrders'?: number;
    /**
     * Operating hours of the outlet
     * @type {string}
     * @memberof VendorConfig
     */
    'operatingHours'?: string;
    /**
     * Allow or disallow cash on delivery
     * @type {boolean}
     * @memberof VendorConfig
     */
    'allowCashOnDelivery'?: boolean;
    /**
     * Contact email for vendor support
     * @type {string}
     * @memberof VendorConfig
     */
    'supportContactEmail'?: string;
    /**
     * Contact phone number for vendor support
     * @type {string}
     * @memberof VendorConfig
     */
    'supportContactPhone'?: string;
}
/**
 * 
 * @export
 * @interface VendorKYCCredentials
 */
export interface VendorKYCCredentials {
    /**
     * URL of the CAC document
     * @type {string}
     * @memberof VendorKYCCredentials
     */
    'CACDocumentURL'?: string;
    /**
     * Tax Idenification Number (TIN)
     * @type {string}
     * @memberof VendorKYCCredentials
     */
    'TIN'?: string;
    /**
     * Type of business
     * @type {string}
     * @memberof VendorKYCCredentials
     */
    'businessType'?: VendorKYCCredentialsBusinessTypeEnum;
    /**
     * URL of the ID proof document
     * @type {string}
     * @memberof VendorKYCCredentials
     */
    'idProofUrl'?: string;
    /**
     * URL of the address proof document
     * @type {string}
     * @memberof VendorKYCCredentials
     */
    'addressProofUrl'?: string;
    /**
     * Business address details
     * @type {Address}
     * @memberof VendorKYCCredentials
     */
    'address'?: Address;
}

export const VendorKYCCredentialsBusinessTypeEnum = {
    Restaurant: 'Restaurant',
    Retail: 'Retail',
    ServiceProvider: 'Service Provider',
    OnlineStore: 'Online Store',
    Other: 'Other'
} as const;

export type VendorKYCCredentialsBusinessTypeEnum = typeof VendorKYCCredentialsBusinessTypeEnum[keyof typeof VendorKYCCredentialsBusinessTypeEnum];

/**
 * 
 * @export
 * @interface VendorPayoutProfile
 */
export interface VendorPayoutProfile {
    /**
     * 
     * @type {string}
     * @memberof VendorPayoutProfile
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof VendorPayoutProfile
     */
    'accountName': string;
    /**
     * 
     * @type {string}
     * @memberof VendorPayoutProfile
     */
    'bankName': string;
    /**
     * 
     * @type {string}
     * @memberof VendorPayoutProfile
     */
    'bankCode': string;
}
/**
 * 
 * @export
 * @interface VendorSummary
 */
export interface VendorSummary {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof VendorSummary
     */
    'id': string;
    /**
     * Unique identifier for the vendor account.
     * @type {string}
     * @memberof VendorSummary
     */
    'accountId': string;
    /**
     * URL to the vendor’s logo image.
     * @type {string}
     * @memberof VendorSummary
     */
    'logo'?: string;
    /**
     * URL to the vendor’s cover photo image.
     * @type {string}
     * @memberof VendorSummary
     */
    'coverPhoto'?: string;
    /**
     * Name of the vendor, used across the TukShop platform.
     * @type {string}
     * @memberof VendorSummary
     */
    'vendorName'?: string;
    /**
     * Short description of the vendor’s business.
     * @type {string}
     * @memberof VendorSummary
     */
    'shortDescription'?: string;
    /**
     * Detailed description of the vendor’s business.
     * @type {string}
     * @memberof VendorSummary
     */
    'longDescription'?: string;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof VendorSummary
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof VendorSummary
     */
    'contactPhone'?: string;
    /**
     * KYC (Know Your Customer) credentials for the vendor.
     * @type {VendorKYCCredentials}
     * @memberof VendorSummary
     */
    'kycCredentials'?: VendorKYCCredentials;
    /**
     * Configuration settings for the vendor.
     * @type {VendorConfig}
     * @memberof VendorSummary
     */
    'config'?: VendorConfig;
    /**
     * Vendor payout profile.
     * @type {VendorPayoutProfile}
     * @memberof VendorSummary
     */
    'payoutProfile'?: VendorPayoutProfile;
    /**
     * Current status of the vendor profile.
     * @type {string}
     * @memberof VendorSummary
     */
    'status': VendorSummaryStatusEnum;
    /**
     * Current verification status of the vendor.
     * @type {string}
     * @memberof VendorSummary
     */
    'verificationStatus': VendorSummaryVerificationStatusEnum;
    /**
     * Flag to check if vendor credentials requires verification
     * @type {boolean}
     * @memberof VendorSummary
     */
    'requiresVerification': boolean;
    /**
     * 
     * @type {string}
     * @memberof VendorSummary
     */
    'verificationDeclineReason': string;
    /**
     * Timestamp when the vendor document was created.
     * @type {string}
     * @memberof VendorSummary
     */
    'createdAt': string;
    /**
     * Timestamp when the vendor document was last updated.
     * @type {string}
     * @memberof VendorSummary
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Member>}
     * @memberof VendorSummary
     */
    'members': Array<Member>;
    /**
     * 
     * @type {Array<Outlet>}
     * @memberof VendorSummary
     */
    'outlets': Array<Outlet>;
    /**
     * 
     * @type {Array<Review>}
     * @memberof VendorSummary
     */
    'reviews': Array<Review>;
}

export const VendorSummaryStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Disabled: 'disabled'
} as const;

export type VendorSummaryStatusEnum = typeof VendorSummaryStatusEnum[keyof typeof VendorSummaryStatusEnum];
export const VendorSummaryVerificationStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Approved: 'approved',
    Declined: 'declined',
    AwaitingReview: 'awaiting-review'
} as const;

export type VendorSummaryVerificationStatusEnum = typeof VendorSummaryVerificationStatusEnum[keyof typeof VendorSummaryVerificationStatusEnum];


/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteMyAccount: async (deleteAccountDTO: DeleteAccountDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAccountDTO' is not null or undefined
            assertParamExists('accountControllerDeleteMyAccount', 'deleteAccountDTO', deleteAccountDTO)
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccountDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccount: async (updateAccountDTO: UpdateAccountDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccount', 'updateAccountDTO', updateAccountDTO)
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdatePassword: async (updateAccountPasswordDTO: UpdateAccountPasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPasswordDTO' is not null or undefined
            assertParamExists('accountControllerUpdatePassword', 'updateAccountPasswordDTO', updateAccountPasswordDTO)
            const localVarPath = `/v1/account/me/update-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerDeleteMyAccount(deleteAccountDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerDeleteMyAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetMyProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPublicDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetMyProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerGetMyProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccount(updateAccountDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdatePassword(updateAccountPasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerDeleteMyAccount(deleteAccountDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfile(options?: any): AxiosPromise<AccountPublicDto> {
            return localVarFp.accountControllerGetMyProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateAccount(updateAccountDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerUpdatePassword(updateAccountPasswordDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @param {DeleteAccountDTO} deleteAccountDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerDeleteMyAccount(deleteAccountDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerGetMyProfile(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerGetMyProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountDTO} updateAccountDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateAccount(updateAccountDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdatePassword(updateAccountPasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MemberApi - axios parameter creator
 * @export
 */
export const MemberApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerDeleteMember: async (memberId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('vendorMemberAdminControllerDeleteMember', 'memberId', memberId)
            const localVarPath = `/v1/vendor/member/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerGetMember: async (memberId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('vendorMemberAdminControllerGetMember', 'memberId', memberId)
            const localVarPath = `/v1/vendor/member/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerGetMembers: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorMemberAdminControllerGetMembers', 'vendorId', vendorId)
            const localVarPath = `/v1/vendor/member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteMemberDTO} inviteMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerNewMemberInvitation: async (inviteMemberDTO: InviteMemberDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteMemberDTO' is not null or undefined
            assertParamExists('vendorMemberAdminControllerNewMemberInvitation', 'inviteMemberDTO', inviteMemberDTO)
            const localVarPath = `/v1/vendor/member/invitation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} memberId 
         * @param {UpdateMemberDTO} updateMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerUpdateMember: async (memberId: string, updateMemberDTO: UpdateMemberDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('vendorMemberAdminControllerUpdateMember', 'memberId', memberId)
            // verify required parameter 'updateMemberDTO' is not null or undefined
            assertParamExists('vendorMemberAdminControllerUpdateMember', 'updateMemberDTO', updateMemberDTO)
            const localVarPath = `/v1/vendor/member/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MemberApi - functional programming interface
 * @export
 */
export const MemberApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MemberApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorMemberAdminControllerDeleteMember(memberId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorMemberAdminControllerDeleteMember(memberId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemberApi.vendorMemberAdminControllerDeleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorMemberAdminControllerGetMember(memberId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorMemberAdminControllerGetMember(memberId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemberApi.vendorMemberAdminControllerGetMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorMemberAdminControllerGetMembers(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Member>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorMemberAdminControllerGetMembers(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemberApi.vendorMemberAdminControllerGetMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InviteMemberDTO} inviteMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO: InviteMemberDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemberApi.vendorMemberAdminControllerNewMemberInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} memberId 
         * @param {UpdateMemberDTO} updateMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorMemberAdminControllerUpdateMember(memberId: string, updateMemberDTO: UpdateMemberDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorMemberAdminControllerUpdateMember(memberId, updateMemberDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemberApi.vendorMemberAdminControllerUpdateMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MemberApi - factory interface
 * @export
 */
export const MemberApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MemberApiFp(configuration)
    return {
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerDeleteMember(memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.vendorMemberAdminControllerDeleteMember(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerGetMember(memberId: string, options?: any): AxiosPromise<Member> {
            return localVarFp.vendorMemberAdminControllerGetMember(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerGetMembers(vendorId: string, options?: any): AxiosPromise<Array<Member>> {
            return localVarFp.vendorMemberAdminControllerGetMembers(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteMemberDTO} inviteMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO: InviteMemberDTO, options?: any): AxiosPromise<Member> {
            return localVarFp.vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} memberId 
         * @param {UpdateMemberDTO} updateMemberDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorMemberAdminControllerUpdateMember(memberId: string, updateMemberDTO: UpdateMemberDTO, options?: any): AxiosPromise<void> {
            return localVarFp.vendorMemberAdminControllerUpdateMember(memberId, updateMemberDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MemberApi - object-oriented interface
 * @export
 * @class MemberApi
 * @extends {BaseAPI}
 */
export class MemberApi extends BaseAPI {
    /**
     * 
     * @param {string} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberApi
     */
    public vendorMemberAdminControllerDeleteMember(memberId: string, options?: RawAxiosRequestConfig) {
        return MemberApiFp(this.configuration).vendorMemberAdminControllerDeleteMember(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberApi
     */
    public vendorMemberAdminControllerGetMember(memberId: string, options?: RawAxiosRequestConfig) {
        return MemberApiFp(this.configuration).vendorMemberAdminControllerGetMember(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberApi
     */
    public vendorMemberAdminControllerGetMembers(vendorId: string, options?: RawAxiosRequestConfig) {
        return MemberApiFp(this.configuration).vendorMemberAdminControllerGetMembers(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteMemberDTO} inviteMemberDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberApi
     */
    public vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO: InviteMemberDTO, options?: RawAxiosRequestConfig) {
        return MemberApiFp(this.configuration).vendorMemberAdminControllerNewMemberInvitation(inviteMemberDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} memberId 
     * @param {UpdateMemberDTO} updateMemberDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberApi
     */
    public vendorMemberAdminControllerUpdateMember(memberId: string, updateMemberDTO: UpdateMemberDTO, options?: RawAxiosRequestConfig) {
        return MemberApiFp(this.configuration).vendorMemberAdminControllerUpdateMember(memberId, updateMemberDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutletApi - axios parameter creator
 * @export
 */
export const OutletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOutletDTO} createOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerCreateOutlet: async (createOutletDTO: CreateOutletDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOutletDTO' is not null or undefined
            assertParamExists('vendorOutletAdminControllerCreateOutlet', 'createOutletDTO', createOutletDTO)
            const localVarPath = `/v1/vendor/outlet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOutletDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerDeleteOutlet: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerDeleteOutlet', 'outletId', outletId)
            const localVarPath = `/v1/vendor/outlet/{outletId}`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetAllVendorOutlets: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerGetAllVendorOutlets', 'vendorId', vendorId)
            const localVarPath = `/v1/vendor/outlet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetOutlet: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerGetOutlet', 'outletId', outletId)
            const localVarPath = `/v1/vendor/outlet/{outletId}`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetOutletSummary: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerGetOutletSummary', 'outletId', outletId)
            const localVarPath = `/v1/vendor/outlet/{outletId}/summary`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerRequestOutletVerification: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerRequestOutletVerification', 'outletId', outletId)
            const localVarPath = `/v1/vendor/outlet/{outletId}/request-verification`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} outletId 
         * @param {UpdateOutletDTO} updateOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerUpdateOutlet: async (outletId: string, updateOutletDTO: UpdateOutletDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('vendorOutletAdminControllerUpdateOutlet', 'outletId', outletId)
            // verify required parameter 'updateOutletDTO' is not null or undefined
            assertParamExists('vendorOutletAdminControllerUpdateOutlet', 'updateOutletDTO', updateOutletDTO)
            const localVarPath = `/v1/vendor/outlet/{outletId}`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOutletDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutletApi - functional programming interface
 * @export
 */
export const OutletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOutletDTO} createOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerCreateOutlet(createOutletDTO: CreateOutletDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerCreateOutlet(createOutletDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerCreateOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerDeleteOutlet(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerDeleteOutlet(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerDeleteOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerGetAllVendorOutlets(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outlet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerGetAllVendorOutlets(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerGetAllVendorOutlets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerGetOutlet(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerGetOutlet(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerGetOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerGetOutletSummary(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutletSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerGetOutletSummary(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerGetOutletSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerRequestOutletVerification(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerRequestOutletVerification(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerRequestOutletVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} outletId 
         * @param {UpdateOutletDTO} updateOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorOutletAdminControllerUpdateOutlet(outletId: string, updateOutletDTO: UpdateOutletDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorOutletAdminControllerUpdateOutlet(outletId, updateOutletDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutletApi.vendorOutletAdminControllerUpdateOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutletApi - factory interface
 * @export
 */
export const OutletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutletApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOutletDTO} createOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerCreateOutlet(createOutletDTO: CreateOutletDTO, options?: any): AxiosPromise<Outlet> {
            return localVarFp.vendorOutletAdminControllerCreateOutlet(createOutletDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerDeleteOutlet(outletId: string, options?: any): AxiosPromise<void> {
            return localVarFp.vendorOutletAdminControllerDeleteOutlet(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetAllVendorOutlets(vendorId: string, options?: any): AxiosPromise<Array<Outlet>> {
            return localVarFp.vendorOutletAdminControllerGetAllVendorOutlets(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetOutlet(outletId: string, options?: any): AxiosPromise<Outlet> {
            return localVarFp.vendorOutletAdminControllerGetOutlet(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerGetOutletSummary(outletId: string, options?: any): AxiosPromise<OutletSummary> {
            return localVarFp.vendorOutletAdminControllerGetOutletSummary(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerRequestOutletVerification(outletId: string, options?: any): AxiosPromise<void> {
            return localVarFp.vendorOutletAdminControllerRequestOutletVerification(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} outletId 
         * @param {UpdateOutletDTO} updateOutletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorOutletAdminControllerUpdateOutlet(outletId: string, updateOutletDTO: UpdateOutletDTO, options?: any): AxiosPromise<void> {
            return localVarFp.vendorOutletAdminControllerUpdateOutlet(outletId, updateOutletDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutletApi - object-oriented interface
 * @export
 * @class OutletApi
 * @extends {BaseAPI}
 */
export class OutletApi extends BaseAPI {
    /**
     * 
     * @param {CreateOutletDTO} createOutletDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerCreateOutlet(createOutletDTO: CreateOutletDTO, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerCreateOutlet(createOutletDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerDeleteOutlet(outletId: string, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerDeleteOutlet(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerGetAllVendorOutlets(vendorId: string, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerGetAllVendorOutlets(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerGetOutlet(outletId: string, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerGetOutlet(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerGetOutletSummary(outletId: string, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerGetOutletSummary(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerRequestOutletVerification(outletId: string, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerRequestOutletVerification(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} outletId 
     * @param {UpdateOutletDTO} updateOutletDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletApi
     */
    public vendorOutletAdminControllerUpdateOutlet(outletId: string, updateOutletDTO: UpdateOutletDTO, options?: RawAxiosRequestConfig) {
        return OutletApiFp(this.configuration).vendorOutletAdminControllerUpdateOutlet(outletId, updateOutletDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VendorApi - axios parameter creator
 * @export
 */
export const VendorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVendorProfileDTO} createVendorProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerCreateVendorProfile: async (createVendorProfileDTO: CreateVendorProfileDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorProfileDTO' is not null or undefined
            assertParamExists('vendorAdminControllerCreateVendorProfile', 'createVendorProfileDTO', createVendorProfileDTO)
            const localVarPath = `/v1/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorProfileDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetMemberships: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetVendorProfile: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerGetVendorProfile', 'vendorId', vendorId)
            const localVarPath = `/v1/vendor/vendor-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetVendorSummary: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerGetVendorSummary', 'vendorId', vendorId)
            const localVarPath = `/v1/vendor/vendor-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerRequestVerification: async (vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerRequestVerification', 'vendorId', vendorId)
            // verify required parameter 'updateVendorPayoutProfileDTO' is not null or undefined
            assertParamExists('vendorAdminControllerRequestVerification', 'updateVendorPayoutProfileDTO', updateVendorPayoutProfileDTO)
            const localVarPath = `/v1/vendor/request-vendor-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorPayoutProfileDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorKYCDTO} updateVendorKYCDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorKYC: async (vendorId: string, updateVendorKYCDTO: UpdateVendorKYCDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorKYC', 'vendorId', vendorId)
            // verify required parameter 'updateVendorKYCDTO' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorKYC', 'updateVendorKYCDTO', updateVendorKYCDTO)
            const localVarPath = `/v1/vendor/vendor-kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorKYCDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorPayoutProfile: async (vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorPayoutProfile', 'vendorId', vendorId)
            // verify required parameter 'updateVendorPayoutProfileDTO' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorPayoutProfile', 'updateVendorPayoutProfileDTO', updateVendorPayoutProfileDTO)
            const localVarPath = `/v1/vendor/vendor-payout-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorPayoutProfileDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorDTO} updateVendorDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorProfile: async (vendorId: string, updateVendorDTO: UpdateVendorDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorProfile', 'vendorId', vendorId)
            // verify required parameter 'updateVendorDTO' is not null or undefined
            assertParamExists('vendorAdminControllerUpdateVendorProfile', 'updateVendorDTO', updateVendorDTO)
            const localVarPath = `/v1/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorApi - functional programming interface
 * @export
 */
export const VendorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateVendorProfileDTO} createVendorProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerCreateVendorProfile(createVendorProfileDTO: CreateVendorProfileDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerCreateVendorProfile(createVendorProfileDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerCreateVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerGetMemberships(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerGetMemberships(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerGetMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerGetVendorProfile(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerGetVendorProfile(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerGetVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerGetVendorSummary(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerGetVendorSummary(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerGetVendorSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerRequestVerification(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerRequestVerification(vendorId, updateVendorPayoutProfileDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerRequestVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorKYCDTO} updateVendorKYCDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerUpdateVendorKYC(vendorId: string, updateVendorKYCDTO: UpdateVendorKYCDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerUpdateVendorKYC(vendorId, updateVendorKYCDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerUpdateVendorKYC']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerUpdateVendorPayoutProfile(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerUpdateVendorPayoutProfile(vendorId, updateVendorPayoutProfileDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerUpdateVendorPayoutProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorDTO} updateVendorDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorAdminControllerUpdateVendorProfile(vendorId: string, updateVendorDTO: UpdateVendorDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorAdminControllerUpdateVendorProfile(vendorId, updateVendorDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorAdminControllerUpdateVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorApi - factory interface
 * @export
 */
export const VendorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateVendorProfileDTO} createVendorProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerCreateVendorProfile(createVendorProfileDTO: CreateVendorProfileDTO, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerCreateVendorProfile(createVendorProfileDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetMemberships(options?: any): AxiosPromise<Array<MemberCredential>> {
            return localVarFp.vendorAdminControllerGetMemberships(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetVendorProfile(vendorId: string, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerGetVendorProfile(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerGetVendorSummary(vendorId: string, options?: any): AxiosPromise<VendorSummary> {
            return localVarFp.vendorAdminControllerGetVendorSummary(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerRequestVerification(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerRequestVerification(vendorId, updateVendorPayoutProfileDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorKYCDTO} updateVendorKYCDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorKYC(vendorId: string, updateVendorKYCDTO: UpdateVendorKYCDTO, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerUpdateVendorKYC(vendorId, updateVendorKYCDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorPayoutProfile(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerUpdateVendorPayoutProfile(vendorId, updateVendorPayoutProfileDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vendorId 
         * @param {UpdateVendorDTO} updateVendorDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorAdminControllerUpdateVendorProfile(vendorId: string, updateVendorDTO: UpdateVendorDTO, options?: any): AxiosPromise<Vendor> {
            return localVarFp.vendorAdminControllerUpdateVendorProfile(vendorId, updateVendorDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VendorApi - object-oriented interface
 * @export
 * @class VendorApi
 * @extends {BaseAPI}
 */
export class VendorApi extends BaseAPI {
    /**
     * 
     * @param {CreateVendorProfileDTO} createVendorProfileDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerCreateVendorProfile(createVendorProfileDTO: CreateVendorProfileDTO, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerCreateVendorProfile(createVendorProfileDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerGetMemberships(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerGetMemberships(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerGetVendorProfile(vendorId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerGetVendorProfile(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerGetVendorSummary(vendorId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerGetVendorSummary(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerRequestVerification(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerRequestVerification(vendorId, updateVendorPayoutProfileDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {UpdateVendorKYCDTO} updateVendorKYCDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerUpdateVendorKYC(vendorId: string, updateVendorKYCDTO: UpdateVendorKYCDTO, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerUpdateVendorKYC(vendorId, updateVendorKYCDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {UpdateVendorPayoutProfileDTO} updateVendorPayoutProfileDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerUpdateVendorPayoutProfile(vendorId: string, updateVendorPayoutProfileDTO: UpdateVendorPayoutProfileDTO, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerUpdateVendorPayoutProfile(vendorId, updateVendorPayoutProfileDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vendorId 
     * @param {UpdateVendorDTO} updateVendorDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorApi
     */
    public vendorAdminControllerUpdateVendorProfile(vendorId: string, updateVendorDTO: UpdateVendorDTO, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorAdminControllerUpdateVendorProfile(vendorId, updateVendorDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



